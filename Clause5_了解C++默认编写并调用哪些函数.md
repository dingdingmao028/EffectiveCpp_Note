#### 了解C++默认编写并调用哪些函数

##### 1.编译器会为空类声明必要的函数

```c++
class Empty{}
等价于
class Empty{
public:
	Empty(){}		//默认无参构造
    
	Empty(const Empty& rhs){
        //对于成员是类类型，对调用该类型的拷贝构造
        //对于成员是内置类型，则是逐比特位拷贝值
    }	//默认拷贝构造，本质上是根据rhs浅拷贝克隆出一个新的对象
    
	Empty& operator=(const Empty& rhs){
        //原理等同于默认拷贝构造
    }	//默认拷贝赋值，本质上是根据rhs修改一个已经存在的对象this
    
	~Empty(){}	//默认析构
};

/*----当声明对象时候，以上4个函数才会被产生-----*/
Empty instance;	//1.调用默认构造

void func(Empty ins){//...}
func(instance) //2.调用拷贝构造
    
Empty instance2=instance //3.调用instance2的拷贝赋值，instance作为参数传入进去   
    
```

##### 2.深层次的分析

```
我们讨论默认拷贝构造，默认拷贝赋值 需要探讨对于对象中成员变量的处理：
1.对象模型：对于对象中的函数，对象实际持有的是函数指针，指向代码区
		  对于变量是基本类型，对象中开辟了相应的空间
		  对于变量是类类型，对象实际持有的是该变量的指针，对象实际是在栈中某个区域
		  对于变量是指针，对象实际持有的是该指针（指向栈空间或者堆空间某个区域）
		  
2.默认拷贝构造，默认拷贝赋值的处理逻辑
		  对于变量是基本类型，逐字节拷贝并覆盖原有的内容
		  对于变量是类类型，调用相应的拷贝构造，拷贝赋值，覆盖之前的对象。如果该对象持有heap上的指针，其变量的拷贝构造，拷贝赋值应合理处理堆指针，因为不会调用其析构
		  对于变量是指针，想基本类型一样，浅拷贝指针指向的地址，所以对象持有指针，必须重载默认拷贝构造，默认拷贝赋值 
		  对于变量是引用或者const常量，默认拷贝构造，默认拷贝赋值无法自动生成，编译器会报错，需要重载后实际处理。
		  
3.拷贝赋值，本质上是一个操作符重载函数，根据rhs修改一个已经存在的对象this
  拷贝构造，本质上是一个构造器，根据rhs浅拷贝克隆出一个新的对象。所以对于 引用 或者 常量 修饰的成员变量。可以在初始化列表中对新的对象进行初始化赋值
```





TODO:疑问

1.对于operator=()，被修改的对象中，引用或者常量修饰的变量，如果修改？



