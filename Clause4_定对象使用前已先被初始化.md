## Clause4 确定对象使用前已先被初始化



##### 1.虽然编译器可能会对未初始化的成员/变量进行默认初始化，但是对于某些平台，读取未初始化的成员/变量会导致程序终结，所以应当确认对象使用前已先被初始化。

##### 2.在C层面，由于考虑初始化会导致成本问题，或许不要求一定初始化，如数组。在C++层面，一般会主动初始化，如std::vector. 容器会自动调用元素的构造器进行初始化。

##### 3.综上最佳做法是：1.对于内置类型，需要手工初始化。2.对于类类型，编译器自动调用构造器

##### 4.关于赋值和初始化

```c++
class example{
public:
    example(std::string str,int i); //构造器
    std::string str_;
    int i_;
}

//反例
example::example(std::string str,int i){
	str_=str;		//赋值操作，并非初始化。初始化动作发生在进入example构造器之前。
        		    //进入构造器之前，首先对str_调用默认构造器进行初始化，赋值操作后str_初始化的对象被舍弃掉，接收传进来的str，显然这是一种浪费。同理，i_在赋值操作之前，是未被初始化的，故在 i_=i之前，i_未被初始化，成为一种潜在的危险
    i_=i;
}

//正例
example::example(std::string str,int i):str_(str),i_(i){}
//initialization list是初始化动作，即在进入构造器之前，初始化阶段，通过对传进来的参数，进行拷贝构造，就完成了对变量的初始化。
//好处是1.避免初始化阶段无谓的浪费，2.避免基本类型未被初始化产生的潜在危险
//比较正例和反例的成本：反例 											正例
//		类类型		  初始化阶段调用默认构造，赋值阶段调用赋值构造 		仅一次赋值阶段调用赋值构造
//		基本类型	  正反例基本一致

//正例引申1
//对于无需赋值的变量，也可以通过initialization list完成初始化
example1::example1():str_(),i_(){} //str_,i_无需被赋值，仅仅被初始化，类类型被调用默认构造器，基本类型赋默认值
//但是这种做法不应成为死板的教条，如若如此，默认构造器会在initialization list对所有的变量进行初始化，颇为夸张。所以，无需初值的变量(不会成为潜在的危险)，可以不用在initialization list进行初始化
//一定需要初始化的变量：1.const类型 2.引用类型 两者都是不可更改的类型

//正例引申2
//对于需要初始化的变量太多，而有些的变量无需在初始化时候就要赋值(即不会成为潜在的危险)的变量，可以在构造器内委托一个函数代为执行赋值操作(伪初始化)。c++11委托构造也可以实现响应的效果
class example2{
    public:
    example2(int i1,int i2):i1_(i1){
          another_fun(i2);
    }
    another_fun(int i2){
        i2_=i2;
        i3_=1;
    }
    private:
    int i1_,i2_,i3_;
}
class example3{			//c++11委托构造
    public:
    example3(int i1,int i2):i1_(i1),example3(){}
    example3():i2_(1),i3_(2){}
    private:
    int i1_,i2_,i3_;
}


```

##### 5.初始化顺序：1.基类先于子类，2.同一类中的成员变量，按照声明的顺序进行初始化（如int arrnum，int arr[] 必然是 arrnum初始化赋值后，才能对数组进行初始化分配内存）

##### 6.全局静态变量的初始化顺序问题

```
假如有一个全局的city静态对象管理多个person对象，person对象的创建需要获取自己所属的city.name。如果在person对象创建初始化时候，city静态对象尚未创建会造成问题。（因为某些原因，无法确定city静态对象是否创建）
解决方式，是使用单例模式返回的city静态对象
```





